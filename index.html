<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'/>
    <title>The Sequencer Open-Source Software</title>
    <link href="http://www.bull.com/css/bull_styles.css" rel="stylesheet" type="text/css" />
  </head>

  <body>
    <a href="https://github.com/pv-bull/sequencer">
      <img style="position: absolute; top: 0; right: 0; border: 0;"
           src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"
           alt="Fork me on GitHub" />
    </a>

    <div class="topzone">
      <a href="https://github.com/pv-bull/sequencer/zipball/master">
        <img border="0" width="90" src="https://github.com/images/modules/download/zip.png"/></a>
      <a href="https://github.com/pv-bull/sequencer/tarball/master">
        <img border="0" width="90" src="https://github.com/images/modules/download/tar.png"/></a>
    </div>

    <div class="text_content" style="margin-left:25px;margin-right:25px">
      <h1>The <a href="http://pv-bull.github.com/sequencer/">Sequencer</a> Open-Source Software
      </h1>

      <h2>QuickStart</h2>
      <p>
      Are you looking for an open-source solution that can:

      <ul>
        <li>ping various devices in parallel with a straightforward
          summary output of who is alive and who is not:
          <pre class="literal-block">
            $ sequencer ping host[1-100,150-200] rack[1-5] switch[2,4,5] anydevice[4-5]
          </pre>
        </li>

        <li>power off a whole set of devices in parallel:
          <pre class="literal-block">
            $ sequencer poweroff rack[1-5] switch[2,4,5] anydevice[4-5]
          </pre>
        </li>

        <li>power on your whole cluster, taking dependencies into
          account (e.g: power on a switch before its connected devices):
          <pre class="literal-block">
            $ sequencer poweron-dep ALL
          </pre>
        </li>

        <li>generate an Emergency PowerOff (EPO) script for your
          data-center/cluster, that takes into account various dependencies
          (power off nodes before switches, clients before server), deals with
          failures kindly and still be very efficient (>4000 nodes in less
          than 10 minutes):

          <ol>
            <li>Compute dependencies:<br><code>$ sequencer depmake epo > epo.dep</code></li>
            <li>Check dependencies:<br><code>$ vi epo.dep</code></li>
            <li>Generate the epo script:<br><code>$ cat epo.dep | sequencer seqmake > epo.seq</code></li>
            <li>Check the script:<br><code>$ vi epo.seq</code></li>
            <li>Execute the script (when required!):<br><code>$ cat epo.seq | sequencer seqexec </code></li>
          </ol>
        </li>
      </ul>


      If this is your case, you can continue with
      an <a href="#overview">overview</a> of <em>the sequencer</em> or jump
      directly to
      the <a href="https://github.com/pv-bull/sequencer/wiki/Tutorial">tutorial</a>
      where you will learn how the "sequencer can ping the world".
      </p>

      <h2><a name="overview">Overview</a></h2>
      <p>
        The sequencer is an engine used by system administrators for
        the computation and execution of sequences of actions over
        hardware or software.
      </p>
      <p>
        As an example, consider using the sequencer for
        starting/stopping a whole set of hardware (or software) components
        such as a whole group of racks including connecting switches. The
        sequencer is:
        <ul>
          <li><b>Smart:</b> the order in which poweroff commands will
            be executed comes from a dependency graph computed from customizable
            dependency rules and the given rack names. For example, switches
            should be powered off <i>after</i> the devices they are connected
            to. Otherwise, those connected devices won't be able to get powered
            off because they will become unreachable.
          </li>
          <li><b>Predictable:</b> the order in which poweroff commands
            will be executed can be verified, modified and recorded before being
            run thanks to the <i>incremental mode</i>.
          </li>
          <li><b>Easy to use:</b> as shown by the following examples:
            <ul>
              <li><i>blackbox mode:</i> sequencer poweroff rack[1-4]</li>
              <li><i>incremental mode:</i> sequencer seqexec -f /root/prod/epo.seq</li>
            </ul>
          </li>
          <li><b>Efficient:</b> the sequencer can execute independent
            instructions in parallel with a customizable upper limit. It has
            powered on/off softly the whole petaflopic
            cluster <a href="http://www.wcm.bull.com/internet/pr/rend.jsp?DocId=567851">Tera-100</a> (more than 4000 nodes, ranked #6 in
            <a href="http://www.top500.org/lists/2010/11">the TOP500 list of
              november 2010</a>) in less than 10 minutes.
          </li>
          <li><b>Robust:</b> when a command does not complete
            correctly, the sequencer does not execute dependent instructions. It
            continues however to execute independent ones. For example, if a
            connected component does not poweroff successfull, the connecting
            switch should not get powered off whereas other switches may.
          </li>
        </ul>
      </p>

      <h3>Main Usage</h3>
      <p>
        The sequencer mostly targets management of clusters and
        data-centers for:
        <ul>
          <li>power on/off: computers, disk arrays, switches, talim/pdu,
            cold doors, and any other manageable devices;
          </li>
          <li>power on/off groups of such devices such as racks or logical groups;
          </li>
          <li>stopping software servers such as NFS or lustre when
            specific actions should be executed on clients before
            the server can be stopped;
          </li>
          <li>launching actions in parallel locally or remotely (ssh);
          </li>
          <li>executing simple workflows (the sequencer computes an
            instruction sequence, a workflow, from dependency rules);
          </li>
          <li>more generally executing an instruction set in a
            pre-defined, computable order.
          </li>
        </ul>
      </p>

      <h3>Main Features</h3>

      <p>
        The sequencer provides the following main features:
        <ul>
          <li>Efficient execution of local and remote actions (ssh)
            in parallel
            using <a href="http://sourceforge.net/apps/trac/clustershell">ClusterShell</a>;
          </li>
          <li>Customization of dependency rules through scripts: no
            programming knowledge required;
          </li>
          <li>Two execution modes: <i>blackbox</i>
            and <i>incremental</i> for two distinct usage targets: daily and
            emergency.
          </li>
          <li>Robust and flexible failure handling: instructions
            depending on a failed one are not executed by default unless told
            otherwise.
          </li>
          <li>Provides various reports type to ease maintenance and
            profiling;
          </li>
          <li>UNIX philosophy: stdout, stderr and returned code are
            dealt with the UNIX way.
          </li>
          <li>Determinist: the order in which dependent instructions
            are executed is determinist (independent instructions might be
            executed in parallel though).
          </li>
        </ul>
      </p>

      <h2>Download & Installation</h2>
      <p>
        Downloading by hand is not normally required. The standard
        Python installation process will do everything for you, in
        particular, <a href="#dependencies">dependencies</a> will be
        taken into account. See
        the <a href="https://github.com/pv-bull/sequencer/wiki">wiki</a>
        for details.
      </p>

      <p>Nevertheless, the following format are still provided:
        <ul>
          <li>Official
              releases: <a href="https://github.com/pv-bull/sequencer/downloads">Project
              Download Web Page</a>
          </li>
          <li>Source code bundles:
            <a href="https://github.com/pv-bull/sequencer/zipball/master">zip</a>
            <a href="https://github.com/pv-bull/sequencer/tarball/master">tar</a>.
          </li>
        </ul>
        You can also clone the project
        with <a href="http://git-scm.com">Git</a> by running:
        <pre>$ git clone git://github.com/pv-bull/sequencer</pre>

      </p>

      <h2>Documentation</h2>
      <p>
        The official documentation is on
        the <a href="https://github.com/pv-bull/sequencer/wiki">wiki</a>.
      </p>

      <h2>Dependencies/Requirements</h2>
      <p>
        The sequencer depends on the following open-source products:
        <ul>
          <li>Python >= 2.6,</li>
          <li>ClusterShell >= 1.5,</li>
          <li>python-graph >= 1.7.0,</li>
          <li>pydot,</li>
          <li>python-lxml >= 2.2.3,</li>
          <li>graphviz >= 2.26, </li>
        </ul>
      </p>
      <h2>License</h2>
      <p>GPL v3</p>

      <h2><a name="contact">Contact & Support</a></h2>
      <h3>Mailing Lists</h3>
      <p>
        Post here for any discussion about the
        sequencer: <a href="mailto:sequencer@freelists.org">sequencer@freelists.org</a>
      </p>
      <h3>Instant Messaging (IRC)</h3>
      <p>
        Either connect with your IRC client to freenode IRC
        (irc.freenode.net) and join channel #sequencer or use
        the <a href="webirc.html" target="_blank">web IRC
          client.</a>
      </p>
      <h3>Professional Support & Services</h3>
      <p>
        Professional support and services for the sequencer can be
        purchased. Contact:
        <a href="mailto:pierre.vigneras@bull.net?subject=Sequencer Support">
          Pierre Vignéras (pierre.vigneras@bull.net)
        </a>
      </p>
      <h3>Authors</h3>
      <p>This software has been designed and implemented
        by <a href="http://www.vigneras.name/pierre/wp/about">Pierre
          Vignéras</a>.
      </p>
    </div>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-10265445-2']);
      _gaq.push(['_trackPageview']);

      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>

  </body>
</html>
